#include "check.h"
#include <stdio.h>

#include "SegmentDisplayManager.h"
#include "SegmentDisplayManager_cfg.h"
#include "GCL_SegmentDisplayManager.h"
#include "GCLMock.h"
#include "BSPMock.h"

#define DOT_SEGMENT_BYTE_INDEX  5
#define DOT_SEGMENT_BIT_INDEX   3
#define T1_SEGMENT_BYTE_INDEX  0
#define T1_SEGMENT_BIT_INDEX   3

// These tests are constructed with an expected segment digit count of 6 and two special segments, a dot (DOT) and an hourglass (T1)
// The CUT will depend on several externally defined symbols which will normally be generated by the FDT tool but are defined here during testing 
//      SegmentDigitCount - determines the number of digits in the segment display.
//      SegmentPatternCount - determines the number of available digit bit patterns
//      DigitBitPattern - a two dimensional array where the first dimension is the digit index and the second is the corresponding digit bit pattern
//      SegmentData - an array of bytes holding the current value of each digit 
//      SpecialSegments - an array of special segments information, byte, bit and GCL read function
//      SpecialSegmentsCount - size of the array above

const uint8 SegmentDigitCount = SEGMENT_DIGIT_COUNT;
const uint8 SegmentPatternCount = SEGMENT_PATTERN_COUNT;
const uint8 DigitBitPattern[SEGMENT_DIGIT_COUNT][SEGMENT_PATTERN_COUNT] = 
{  
    {0xF5, 0x60, 0xB6, 0xF2, 0x63, 0xD3, 0xD7, 0x71, 0xF7, 0xF3},
    {0xFA, 0x60, 0xBC, 0xF4, 0x66, 0xD6, 0xDE, 0x72, 0xFE, 0xF6},
    {0xFA, 0x60, 0xBC, 0xF4, 0x66, 0xD6, 0xDE, 0x72, 0xFE, 0xF6},
    {0xFA, 0x60, 0xBC, 0xF4, 0x66, 0xD6, 0xDE, 0x72, 0xFE, 0xF6},
    {0xFA, 0x60, 0xBC, 0xF4, 0x66, 0xD6, 0xDE, 0x72, 0xFE, 0xF6},
    {0xF5, 0x60, 0xB6, 0xF2, 0x63, 0xD3, 0xD7, 0x71, 0xF7, 0xF3}
};
const uint8 SpecialSegmentsCount = 2;
SpecialSegment SpecialSegments[2] =
{
    { .byteIndex = T1_SEGMENT_BYTE_INDEX, .bitIndex = T1_SEGMENT_BIT_INDEX, .gclReadFunction = GCL_Read_SegmentDisplayManager_T1SegmentStatus }, // T1
    { .byteIndex = DOT_SEGMENT_BYTE_INDEX, .bitIndex = DOT_SEGMENT_BIT_INDEX, .gclReadFunction = GCL_Read_SegmentDisplayManager_DOTSegmentStatus }  // DOT
};
uint8 SegmentData[SEGMENT_DIGIT_COUNT];

void AssertDotSegmentActive();
void AssertT1SegmentActive();
void AssertDigitBitPattern(uint8 index, uint8 displayValue);
void AssertAllSegmentsOff(void);    
void AssertDigitDisplayValues(uint8 segment1, uint8 segment2, uint8 segment3, uint8 segment4, uint8 segment5, uint8 segment6);

START_TEST(RunningAndValue123456_SegmentsDisplay123456)
{
    // Arrange
    SegmentDisplayManager_Init();
    GCLMock_SetPowerMode(POWER_IGNITION_ON);
    SegmentDisplayManager_Run();
    GCLMock_SetDisplayValue(123456);
    
    // Act
    SegmentDisplayManager_Run();
    
    // Assert
    AssertDigitDisplayValues(1, 2, 3, 4, 5, 6);
}
END_TEST

START_TEST(RunningAndValue123_SegmentsDisplay000123)
{
    // Arrange
    SegmentDisplayManager_Init();
    GCLMock_SetPowerMode(POWER_IGNITION_ON);
    SegmentDisplayManager_Run();
    GCLMock_SetDisplayValue(123);
    
    // Act
    SegmentDisplayManager_Run();
    
    // Assert
    AssertDigitDisplayValues(0, 0, 0, 1, 2, 3);
}
END_TEST

START_TEST(ConsecutiveRunsWithSameValue_DoesNotCallBSPAgain)
{
    // Arrange
    SegmentDisplayManager_Init();
    GCLMock_SetPowerMode(POWER_IGNITION_ON);
    SegmentDisplayManager_Run();
    GCLMock_SetDisplayValue(123456);
    SegmentDisplayManager_Run();

    // Act
    uint8 callCountBefore = BSPMock_SetDisplaySegments_CallCount();    
    SegmentDisplayManager_Run();
    uint8 callCountAfter = BSPMock_SetDisplaySegments_CallCount();    
    
    // Assert
    ck_assert_msg(callCountAfter == callCountBefore, "Consecutive runs with the same value should not call the BSP again!");
}
END_TEST

START_TEST(DotSegmentActive_SetsDotSegmentActive)
{
    // Arrange
    SegmentDisplayManager_Init();
    GCLMock_SetPowerMode(POWER_IGNITION_ON);
    SegmentDisplayManager_Run();
    
    // Act
    GCLMock_SetDotSegmentOn();
    SegmentDisplayManager_Run();
    
    // Assert
    AssertDotSegmentActive();
}
END_TEST

START_TEST(ValueSetAndDotSegmentActive_DoesNotAffectOtherSegmentsOnSameByte)
{
    // Arrange
    SegmentDisplayManager_Init();
    GCLMock_SetPowerMode(POWER_IGNITION_ON);
    GCLMock_SetDisplayValue(123456);
    SegmentDisplayManager_Run();
    SegmentDisplayManager_Run();
    
    // Act
    GCLMock_SetDotSegmentOn();
    SegmentDisplayManager_Run();
    
    // Assert
    AssertDotSegmentActive();
    AssertDigitDisplayValues(1,2,3,4,5,6);
}
END_TEST

START_TEST(DotSegmentActiveThenValueChanges_DoesNotAffectDotSegment)
{
    // Arrange
    SegmentDisplayManager_Init();
    GCLMock_SetPowerMode(POWER_IGNITION_ON);
    GCLMock_SetDotSegmentOn();
    SegmentDisplayManager_Run();
    SegmentDisplayManager_Run();
    
    // Act
    GCLMock_SetDisplayValue(123456);
    SegmentDisplayManager_Run();
    
    // Assert
    AssertDotSegmentActive();
    AssertDigitDisplayValues(1,2,3,4,5,6);
}
END_TEST

START_TEST(SpecialSegmentsActiveWhenIgnitionCycles_SpecialSegmentsStillActive)
{
    // Arrange
    SegmentDisplayManager_Init();
    GCLMock_SetPowerMode(POWER_IGNITION_ON);
    GCLMock_SetDotSegmentOn();
    GCLMock_SetT1SegmentOn();
    SegmentDisplayManager_Run();
    SegmentDisplayManager_Run();
    AssertDotSegmentActive();
    AssertT1SegmentActive();
    
    // Act
    GCLMock_SetPowerMode(POWER_IGNITION_OFF);
    SegmentDisplayManager_Run();
    GCLMock_SetPowerMode(POWER_IGNITION_ON);
    SegmentDisplayManager_Run();
    SegmentDisplayManager_Run();

    // Assert
    AssertDotSegmentActive();
    AssertT1SegmentActive();
}
END_TEST

void setup()
{
    for (int i=0; i<SpecialSegmentsCount; ++i)
    {
        SpecialSegments[i].lastStatus = 0;
    }
    
    GCLMock_Reset();
    BSPMock_Reset();
}

void teardown()
{

}

int main(void)
{
    Suite *s = suite_create("SegmentDisplayManagerTestSuite");
    TCase*  tc = tcase_create("AllTests");

    tcase_add_checked_fixture(tc, setup, teardown);

    tcase_add_test(tc, RunningAndValue123456_SegmentsDisplay123456);
    tcase_add_test(tc, RunningAndValue123_SegmentsDisplay000123);
    tcase_add_test(tc, ConsecutiveRunsWithSameValue_DoesNotCallBSPAgain);
    tcase_add_test(tc, DotSegmentActive_SetsDotSegmentActive);
    tcase_add_test(tc, ValueSetAndDotSegmentActive_DoesNotAffectOtherSegmentsOnSameByte);
    tcase_add_test(tc, DotSegmentActiveThenValueChanges_DoesNotAffectDotSegment);
    tcase_add_test(tc, SpecialSegmentsActiveWhenIgnitionCycles_SpecialSegmentsStillActive);
    

    
    suite_add_tcase(s, tc);
    SRunner *sr = srunner_create(s);

    srunner_run_all(sr, CK_NORMAL);
    int number_failed = srunner_ntests_failed(sr);
    srunner_free(sr);
    return number_failed;

}

void AssertDotSegmentActive()
{
    uint8 segmentData = BSPMock_GetSegment(DOT_SEGMENT_BYTE_INDEX);
 
    uint8 bitMask = (0x01 << DOT_SEGMENT_BIT_INDEX);
    
    ck_assert_msg(segmentData & bitMask, "Dot segment bit was not set!");
}

void AssertT1SegmentActive()
{
    uint8 segmentData = BSPMock_GetSegment(T1_SEGMENT_BYTE_INDEX);
 
    uint8 bitMask = (0x01 << T1_SEGMENT_BIT_INDEX);
    
    ck_assert_msg(segmentData & bitMask, "Hourglass segment bit was not set!");
}


void AssertDigitDisplayValues(uint8 segment1, uint8 segment2, uint8 segment3, uint8 segment4, uint8 segment5, uint8 segment6)
{
    uint8 digitCount = 0;
    uint8* segmentStatus = BSPMock_GetSegments(&digitCount);
    
    ck_assert_msg(digitCount == 6, "BSPMock reported an unexpected segment count! (actual:%d, expected:6", digitCount);

    uint8 expectedBitPattern = DigitBitPattern[0][segment1];
    ck_assert_msg(segmentStatus[0] & expectedBitPattern, "Bit pattern mismatch for first digit  expected:%d  actual:%d", expectedBitPattern, segmentStatus[0]);
    expectedBitPattern = DigitBitPattern[1][segment2];
    ck_assert_msg(segmentStatus[1] & expectedBitPattern, "Bit pattern mismatch for second digit   expected:%d  actual:%d", expectedBitPattern, segmentStatus[1]);
    expectedBitPattern = DigitBitPattern[2][segment3];
    ck_assert_msg(segmentStatus[2] & expectedBitPattern, "Bit pattern mismatch for third digit   expected:%d  actual:%d", expectedBitPattern, segmentStatus[2]);
    expectedBitPattern = DigitBitPattern[3][segment4];
    ck_assert_msg(segmentStatus[3] & expectedBitPattern, "Bit pattern mismatch for fourth digit   expected:%d  actual:%d", expectedBitPattern, segmentStatus[3]);
    expectedBitPattern = DigitBitPattern[4][segment5];
    ck_assert_msg(segmentStatus[4] & expectedBitPattern, "Bit pattern mismatch for fifth digit   expected:%d  actual:%d", expectedBitPattern, segmentStatus[4]);
    expectedBitPattern = DigitBitPattern[5][segment6];
    ck_assert_msg(segmentStatus[5] & expectedBitPattern, "Bit pattern mismatch for sitxh digit   expected:%d  actual:%d", expectedBitPattern, segmentStatus[5]);
    
}

void AssertAllSegmentsOff(void)
{
    uint8 digitCount = 0;
    uint8* segmentStatus = BSPMock_GetSegments(&digitCount);

    ck_assert_msg(digitCount > 0, "Received a zero digit count from BSPMock!");

    for (int i=0; i<digitCount; ++i)
    {
        ck_assert_msg(segmentStatus[i] == 0x00, "Digit %d was not OFF (actual value: 0x%02x)", i, segmentStatus[i]);
    }
}