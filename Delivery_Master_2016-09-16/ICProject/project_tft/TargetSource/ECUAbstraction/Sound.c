/*                                                               */
/* FILE        : Sound.c                                         */
/* DATE        : 2015-04-30                                      */
/* AUTHOR      : Cao ChenGuang                                   */
/* DESCRIPTION : source file of sound module                     */
/* HISTORY     : 1.0.0 release for the first time.               */
/*                                                               */
/* NOTE        : All Rights reserved by DETC, Technology Centre  */
/*               Last Modified By Cao ChenGuang on 2015-04-30    */
/*                                                               */
/*****************************************************************/
#include "BSP.h"
#include "Sound.h"
#include "IODefine.h"
#include "jdp.h"
#include "SGL.h"
#include "SIUL.h"

#define INFINITE_SND       300u

#define ACTIVE_BUZZER_DUMMY  0u
#define ACTIVE_BUZZER_OFF    1u
#define ACTIVE_BUZZER_ON     2u
#define ACTIVE_BUZZER_1HZ    3u


static BSP_Sound gCurSound;
static uint32 u32g_SndPhase;
static BSP_SoundGenStatus g_SndStatus;
static uint32 u32g_RepSndStopFlag;
static uint32 u32g_ActiveBuzzerFlag;

/*
 * Name        : ECU_SoundInit
 * Description : initialize sound devices
 * Arguments   : none
 * Return      : none
 */
void ECU_Sound_Init(void)
{
	u32g_SndPhase = 0;
	g_SndStatus = BSP_SOUND_GEN_INACTIVE;
	u32g_RepSndStopFlag = 0u;
	u32g_ActiveBuzzerFlag = ACTIVE_BUZZER_DUMMY;

	SIUL_Output(ACTIVE_BUZZER, 0u);
	SGL_Init();
}

/*
 * Name        : BSP_Sound_Buzzer
 * Description : produce active buzzer sound
 * Arguments   : BSP_BuzzerSound
 * Return      : none
 */
void BSP_Sound_Buzzer(BSP_BuzzerSound sound)
{
	if(sound == BSP_SOUND_ON)
	{
		SIUL_Output(ACTIVE_BUZZER, 1u);
		u32g_ActiveBuzzerFlag = ACTIVE_BUZZER_ON;
	}
	else if(sound == BSP_SOUND_1HZ)
	{
		u32g_ActiveBuzzerFlag = ACTIVE_BUZZER_1HZ;
	}
	else
	{
		u32g_ActiveBuzzerFlag = ACTIVE_BUZZER_DUMMY;    /* do nothing */
	}
}

/*
 * Name        : BSP_StopActiveSoundGeneration
 * Description : Stops all sound generation from the active buzzer
 * Arguments   : BSP_BuzzerSound
 * Return      : none
 */
void BSP_StopActiveSoundGeneration(void)
{
    u32g_ActiveBuzzerFlag = ACTIVE_BUZZER_OFF;
}

/*
 * Name        : BSP_Get_ActiveSoundGenerationStatus
 * Description : return the status of the active sound generation module
 * Arguments   : BSP_BuzzerSound
 * Return      : none
 */
BSP_SoundGenStatus BSP_Get_ActiveSoundGenerationStatus(void)
{
    if(u32g_ActiveBuzzerFlag == ACTIVE_BUZZER_DUMMY)
    {
        return BSP_SOUND_GEN_INACTIVE;
    }
    else
    {
        return BSP_SOUND_GEN_ACTIVE;
    }
}

BSP_StdReturnType BSP_Service_SoundGen(BSP_Sound Sound, uint8 Volume)
{
	BSP_StdReturnType ret;

	Volume = Volume;             /* prevent compiler's warning */
	gCurSound = Sound;
	ret = BSP_OK;
	u32g_RepSndStopFlag = 0u;
	g_SndStatus = BSP_SOUND_GEN_ACTIVE;

/* The following codes needs to be generated by GUI
	      Warning: switch-case can NOT be correctly interpreted by compiler here! */
    if(Sound == BSP_SOUND_TICK)
	{
	    MCU_ToneSet(704u);
        u32g_SndPhase = 0;
        SGL_SET_DURATION(100000u);
	    SGL_SET_MODE(1u);
	}
	else if(Sound == BSP_SOUND_TACK)
	{
	    MCU_ToneSet(1023u);
        SGL_SET_DURATION(100000u);
	    SGL_SET_MODE(1u);
	}
	else if(Sound == BSP_SOUND_WARN3)
	{
	    u32g_SndPhase = 0;
	    MCU_ToneSet(1999u);
	    SGL_SET_HIGH(1000000u);
	    SGL_SET_LOW(500000u);
	    SGL_SET_DURATION(1500000u);
	    SGL_SET_MODE(5u);
	    SGL_SET_DURATION(1000000u);    /* duration for the next cycle */
	}
	else if(Sound == BSP_SOUND_WARN4)
	{
	    u32g_SndPhase = 0;
	    MCU_ToneSet(1999u);
	    SGL_SET_HIGH(1000000u);
	    SGL_SET_LOW(500000u);
	    SGL_SET_DURATION(1500000u);
	    SGL_SET_MODE(5u);
	    SGL_SET_DURATION(2000000u);    /* duration for the next cycle */     
	}
	else if(Sound == BSP_SOUND_WARN5)
	{
	    u32g_SndPhase = 0;
	    MCU_ToneSet(1999u);
	    SGL_SET_HIGH(1000000u);
	    SGL_SET_LOW(500000u);
	    SGL_SET_DURATION(1500000u);
	    SGL_SET_MODE(5u);
	    SGL_SET_DURATION(3000000u);    /* duration for the next cycle */
	}
	else
	{
	    g_SndStatus = BSP_SOUND_GEN_INACTIVE;
	    ret = BSP_INVALID_RANGE;
	}
	/* end of generated codes */

    return ret;	
}

/*
 * Name        : BSP_Service_StopSoundGeneration
 * Description : stop continuous sound
 * Arguments   : none
 * Return      : none
 */
void BSP_Service_StopSoundGeneration(void)
{
	u32g_RepSndStopFlag = 1u;           /* stop passive buzzer */
}

/*
 * Name        : BSP_Get_SoundGenerationStatus
 * Description : get sound status 
 * Arguments   : none
 * Return      : none
 */
BSP_SoundGenStatus BSP_Get_SoundGeneratorStatus(void)
{
    return g_SndStatus;
}

/*
 * Name        : BSP_ReportError_SoundGeneration
 * Description : Checks for and reports error
 * Arguments   : FTB - Failure Type Byte
 * Return      : none
 */
BSP_StdReturnType BSP_ReportError_SoundGeneration(uint8* FTB)
{
	*FTB = 0;
    return BSP_NOT_SUPPORTED;
}

/*
 * Name        : ActiveBuzzerRun
 * Description : active buzzer beeps every 1s
 * Arguments   : none
 * Return      : none
 */
void BSP_ActiveBuzzerRun(void)
{
    static uint32 u32s_ActiveBuzzerCnt = 0u;
    static uint32 u32s_ActiveBuzzerStatus = 0u;

    if(u32g_ActiveBuzzerFlag == ACTIVE_BUZZER_1HZ)
    {
        if (u32s_ActiveBuzzerCnt >= 500u)
        {
            u32s_ActiveBuzzerCnt = 0;
            /* revert active buzzer */
            SIUL_Output(ACTIVE_BUZZER, u32s_ActiveBuzzerStatus);
            u32s_ActiveBuzzerStatus = (!u32s_ActiveBuzzerStatus) & 0x01u;
        }
        else
        {
            u32s_ActiveBuzzerCnt++;
        }
    }
    else if(u32g_ActiveBuzzerFlag == ACTIVE_BUZZER_OFF)
    {
        SIUL_Output(ACTIVE_BUZZER, 0);    /* stop the active buzzer */
        u32g_ActiveBuzzerFlag = ACTIVE_BUZZER_DUMMY;
    }
    else    /* do nothing in the case of ACTIVE_BUZZER_ON and ACTIVE_BUZZER_DUMMY */
    {
    	;
    }
}

void SglISR(void)
{
	RESET_SGL_MODE();
	CLEAR_SGL_INTC_FLAG();

	 /* repetitive sound or tick or tack stops */
	if((u32g_RepSndStopFlag == 1u) ||(gCurSound == BSP_SOUND_TICK)|| (gCurSound == BSP_SOUND_TACK))
	{
		g_SndStatus = BSP_SOUND_GEN_INACTIVE;
	    return;
	}

    if(gCurSound == BSP_SOUND_WARN3)
	{
	    if(u32g_SndPhase == 0u)
	    {
	    	u32g_SndPhase = 1u;
	    	SGL_SET_HIGH(500000u);
	    	SGL_SET_LOW(500000u);
	    	SGL_SET_MODE(5u);
	    	SGL_SET_DURATION(1500000u);    /* duration for the next cycle */
	    }
	    else
	    {
	    	u32g_SndPhase = 0u;
	    	SGL_SET_HIGH(1000000u);
	    	SGL_SET_LOW(500000u);
	    	SGL_SET_MODE(5u);
	    	SGL_SET_DURATION(1000000u);    /* duration for the next cycle */
	    }
	}
	else if(gCurSound == BSP_SOUND_WARN4)
	{
		if(u32g_SndPhase == 0u)
	   	{
	   	    u32g_SndPhase = 1u;
	    	SGL_SET_HIGH(500000u);
	    	SGL_SET_LOW(500000u);
	    	SGL_SET_MODE(5u);
	    	SGL_SET_DURATION(1500000u);    /* duration for the next cycle */
	   	}
		else
	   	{
	   	    u32g_SndPhase = 0;
	    	SGL_SET_HIGH(1000000u);
	    	SGL_SET_LOW(500000u);
	    	SGL_SET_MODE(5u);
	    	SGL_SET_DURATION(2000000u);    /* duration for the next cycle */
	   	}
	}
	else if(gCurSound == BSP_SOUND_WARN5)
	{
		if(u32g_SndPhase == 0u)
        {
		    u32g_SndPhase = 1u;
			SGL_SET_HIGH(500000u);
			SGL_SET_LOW(500000u);
			SGL_SET_MODE(5u);
			SGL_SET_DURATION(1500000u);    /* duration for the next cycle */	
        }
		else
	    {
			u32g_SndPhase = 0;
			SGL_SET_HIGH(1000000u);
			SGL_SET_LOW(500000u);
			SGL_SET_MODE(5u);
			SGL_SET_DURATION(3000000u);    /* duration for the next cycle */
		}
	}
	else
	{
		;    /* Do nothing */
	}
}
