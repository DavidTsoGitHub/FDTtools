/*=======[I N C L U D E S]====================================================*/
#include "ComStack_Types.h"
#include "Dcm_Dsp.h"
#include "Dcm_Types.h"
#include "Dcm_Internel.h"
#include "Appl.h"
#include "SecM_Cfg.h"
#include "Board.h"

/*=======[T Y P E   D E F I N I T I O N S]====================================*/

/* data structure for program */
typedef struct
{
    /* data program start address */
    uint32 address;

    /* data program block Index(compare with parameter transfered by test) */
    uint8 blockId;

    /* if program condition is passed */
    boolean condition;
    
}Dcm_DspProgramType;

/* data structure for security access */
typedef struct
{
    /* DCM security access attempt num counter */
    uint8 attempt;

    /* if seed has requested */
    boolean seedReq;

    /* the last requested seed Id */
    uint8 seedIdReq;

    /* seed which generated by SecM module */
    SecM_SeedType seed;
    
}Dcm_DspSecurityType;

/*=======[I N T E R N A L   D A T A]==========================================*/
STATIC Dcm_DspProgramType dcmDspProgram;
STATIC Dcm_DspSecurityType dcmDspSec;

/*=======[I N T E R N A L   F U N C T I O N   D E C L A R A T I O N S]========*/
STATIC uint32 Dcm_Get4Byte(const uint8* data);

STATIC void Dcm_Set4Byte(uint8* destData,
                         const uint32 sourceData);
                         
STATIC boolean Dcm_CheckSubFuncSession(const Dcm_SessionType * sessionTable);

STATIC boolean Dcm_CheckMsgLength(const uint16 minlength,
                                  const uint16 receivedLength);
                                  
STATIC boolean Dcm_CheckSecurityCondition(const Dcm_SecurityType * secLevTable);

STATIC boolean Dcm_CheckSubFuncFind(const boolean find,
                                    const Dcm_BuffType * rxBuff);
                                    
STATIC boolean Dcm_CheckConditionCorrect(const boolean condition);

STATIC boolean Dcm_CheckReqOutOfRange(const boolean condition);

STATIC void Dcm_RequestSeed(const Dcm_SecurityRowType * secTablePtr,
                            const Dcm_BuffType * rxBuff,
                            Dcm_BuffType * txBuff);
                            
STATIC void Dcm_SendKey(const Dcm_SecurityRowType * secTablePtr,
                        const Dcm_BuffType * rxBuff,
                        Dcm_BuffType * txBuff);

/*=======[F U N C T I O N   I M P L E M E N T A T I O N S]====================*/
/******************************************************************************/
/**
 * @brief               <DCM module dsp initialize>
 * 
 * <DCM module dsp initialize> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <NONE>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <NONE>    
 */
/******************************************************************************/    
void Dcm_DspInit(void)
{
	/* set program condition is allowed */
    dcmDspProgram.condition = TRUE;
    
    /* clear erase block id */
    dcmDspProgram.blockId = 0x00u;
    
    /* clear program address */
    dcmDspProgram.address = 0x00uL;

	/* clear security access attempt num */
    dcmDspSec.attempt = 0x00u;
    
    /* set seed has not requested */
    dcmDspSec.seedReq = FALSE;
    
    return;
}

/******************************************************************************/
/**
 * @brief               <handle service 0x10 session control>
 * 
 * <handle service 0x10 session control> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <NONE>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <NONE>    
 */
/******************************************************************************/
void Dcm_RecvMsg10(const Dcm_BuffType * rxBuff,Dcm_BuffType * txBuff)
{
    boolean positiveRspReq = TRUE;
    Dcm_SessionType sessionValue = rxBuff->pduInfo.SduDataPtr[1];
    uint8 sessionTableIndex = DCM_SESSION_NUM;
    const Dcm_SessionRowType * sessionTablePtr = Dcm_SessionRow;
    boolean sessionFind = FALSE;
    boolean processContinue = TRUE;
    
    /* 
    ** if received pdu Id is function address, analyze the response request bit
    ** in subfunction 
    */
    if (DCM_RX_FUNC_PDU_ID == rxBuff->pduId)
    {
    	/* get subfunction */
        sessionValue &= DCM_RSP_CLEAR_REQUIRED;
        
        /* check if response is needed */
        if ((rxBuff->pduInfo.SduDataPtr[1] & DCM_RSP_NOT_REQUIRED) > 0x00u)
        {
            positiveRspReq = FALSE;
        }
    }

	/* find session mode subfunction */
    while ((sessionTableIndex > 0) && (FALSE == sessionFind))
    {
        sessionTableIndex --;
        if (sessionValue == sessionTablePtr->sessionType)
        {
            sessionFind = TRUE;
        }
        else
        {
            sessionTablePtr ++;
        }
    }
    
    /* if did not find subfunction,send NRC */
    processContinue = Dcm_CheckSubFuncFind(sessionFind,rxBuff);
    
    if (TRUE == processContinue)
    {
    	/* check if subfunction is supported in current session, other wise send NRC */
        processContinue = Dcm_CheckSubFuncSession(sessionTablePtr->sessionSupp);
    }  
    
    if (TRUE == processContinue)
    {
    	/* check if received message length is right, other wise send NRC */
        processContinue = Dcm_CheckMsgLength(0x02u,rxBuff->pduInfo.SduLength);
    }

    if (TRUE == processContinue)
    {
    	/* check if subfunction is supported in current security level, other wise send NRC */
        processContinue = Dcm_CheckSecurityCondition(sessionTablePtr->securitySupp);
    }

    if (TRUE == processContinue)
    {
        if (DCM_SESSION_PROGRAMMING == sessionValue)
        {
        	/* check if program condition is accepted, other wise send NRC */
            processContinue = Dcm_CheckConditionCorrect(dcmDspProgram.condition);
        }
    }
    
    if (TRUE == processContinue)
    {

    	/* If we receive a default session request we should escape out of the boot.
    	 * Set the magic word in special function register and reset.  This should not be
    	 * done if we entered boot through stay in boot. */
    	if ((sessionValue == DCM_SESSION_DEFAULT) && (!Board_IsStayInBoot())) {
    		Board_SetBootRequest(FL_EXT_DEFAULT_SESSION_RECEIVED, FL_EXT_DEFAULT_SESSION_RECEIVED_INV);
    		Board_Reset();
    	}

    	Dcm_SetSessionMode(sessionValue);
        
        if (TRUE == positiveRspReq)
        {
            /* set response message */		
		    txBuff->pduInfo.SduDataPtr[0] = 0x50u;
		    txBuff->pduInfo.SduDataPtr[1] = rxBuff->pduInfo.SduDataPtr[1];
		    txBuff->pduInfo.SduDataPtr[2] = (uint8)DCM_P2MAX_TIME;
		    txBuff->pduInfo.SduDataPtr[3] = (uint8)(((uint16) DCM_P2MAX_TIME) >> 0x08u);
		    txBuff->pduInfo.SduDataPtr[4] = (uint8)DCM_P2SMAX_TIME;
		    txBuff->pduInfo.SduDataPtr[5] = (uint8)(((uint16) DCM_P2SMAX_TIME) >> 0x08u);
		    txBuff->pduInfo.SduLength = 0x06u;
            Dcm_SendRsp();
        }
        else
        {
            /* reset service process */
            Dcm_ServiceFinish();
        }
    }
    
    return;	
}

/******************************************************************************/
/**
 * @brief               <handle service 0x11 ECU reset>
 * 
 * <handle service 0x11 ECU reset> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <NONE>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <NONE>    
 */
/******************************************************************************/
void Dcm_RecvMsg11(const Dcm_BuffType * rxBuff,Dcm_BuffType * txBuff)
{ 
    boolean positiveRspReq = TRUE;
    Dcm_ResetType resetValue = rxBuff->pduInfo.SduDataPtr[1];
    uint8 resetTableIndex = DCM_RESET_NUM;
    const Dcm_ResetRowType * resetTablePtr = Dcm_ResetRow;
    boolean resetFind = FALSE;
    boolean processContinue = TRUE;
    (void)txBuff;  /* to avoid compiler warning */

     /* 
    ** if received pdu Id is function address, analyze the response request bit
    ** in subfunction 
    */   
    if (DCM_RX_FUNC_PDU_ID == rxBuff->pduId)
    {
    	/* get subfunction */
        resetValue &= DCM_RSP_CLEAR_REQUIRED;
        
        /* check if response is needed */
        if ((rxBuff->pduInfo.SduDataPtr[1] & DCM_RSP_NOT_REQUIRED) > 0x00u)
        {
            positiveRspReq = FALSE;
        }
    }

	/* find reset mode subfunction */
    while ((resetTableIndex > 0) && (FALSE == resetFind))
    {
        resetTableIndex --;
        if (resetValue == resetTablePtr->resetType)
        {
            resetFind = TRUE;
        }
        else
        {
            resetTablePtr ++;
        }
    }
    
    /* if did not find subfunction,send NRC */
    processContinue = Dcm_CheckSubFuncFind(resetFind,rxBuff);
    
    if (TRUE == processContinue)
    {
    	/* check if subfunction is supported in current session, other wise send NRC */
        processContinue = Dcm_CheckSubFuncSession(resetTablePtr->sessionSupp);
    }  
    
    if (TRUE == processContinue)
    {
    	/* check if received message length is right, other wise send NRC */
        processContinue = Dcm_CheckMsgLength(0x02u,rxBuff->pduInfo.SduLength);
    }

    if (TRUE == processContinue)
    {
    	/* check if subfunction is supported in current security level, other wise send NRC */
        processContinue = Dcm_CheckSecurityCondition(resetTablePtr->securitySupp);
    }
    
    if (TRUE == processContinue)
    {        
        if (TRUE == positiveRspReq)
        {
			if(resetValue == 0x02u)
			{
				/* set response message */
				txBuff->pduInfo.SduDataPtr[0] = 0x51u;
				txBuff->pduInfo.SduDataPtr[1] = 0x02u;
				txBuff->pduInfo.SduDataPtr[2] = 0x05u;
				txBuff->pduInfo.SduLength = 0x03u;
				Dcm_SendRsp();
			}
			else
			{
				/* Set boot request values here that indicate that the application should
				* respond to the ECU_RESET request service */
				Board_SetBootRequest(FL_APPL_RESPONSE_TO_RESET, FL_APPL_RESPONSE_TO_RESET_INV);

				/* ECU will reset after 100ms */
				Board_Reset();
			}
        }
        else
        {
            /* reset service process */
            Dcm_ServiceFinish();
        }
    }
    
    return;
}

#if(DCM_READDID_NUM > 0)
/******************************************************************************/
/**
 * @brief               <handle service 0x22 read data by identifier>
 * 
 * <handle service 0x22 read data by identifier> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <NONE>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <NONE>    
 */
/******************************************************************************/
void Dcm_RecvMsg22(const Dcm_BuffType * rxBuff,Dcm_BuffType * txBuff)
{
    uint16 readDid;
    uint8 readTableIndex = DCM_READDID_NUM;
    const Dcm_ReadDidRowType * readTablePtr = Dcm_ReadDidRow;
    boolean didFind = FALSE;
    boolean processContinue = TRUE;

	/* get read data Id */
    readDid = ((uint16)rxBuff->pduInfo.SduDataPtr[1]) << 0x08u;
    readDid += (uint16)rxBuff->pduInfo.SduDataPtr[2];
    
    /* find read data Id in configured read data table */
    while ((readTableIndex > 0) && (FALSE == didFind))
    {
        readTableIndex --;
        if (readDid == readTablePtr->DID)
        {
            didFind = TRUE;
        }
        else
        {
            readTablePtr ++;
        }
    }

	/* if did not find DID,send NRC */
    processContinue = Dcm_CheckReqOutOfRange(didFind);
   
    if (TRUE == processContinue)
    {
    	/* check if received message length is right, other wise send NRC */
        processContinue = Dcm_CheckMsgLength(0x03u,rxBuff->pduInfo.SduLength);
    }

    if (TRUE == processContinue)
    {
    	/* check if DID is supported in current security level, other wise send NRC */
        processContinue = Dcm_CheckSecurityCondition(readTablePtr->securitySupp);
    }
    
    if (TRUE == processContinue)
    {        
        uint16 readLength;
        
        /* excute read API,return read length */
        readLength = readTablePtr->readDataFct(&txBuff->pduInfo.SduDataPtr[3]);

	    txBuff->pduInfo.SduDataPtr[0] = 0x62u;
	    txBuff->pduInfo.SduDataPtr[1] = rxBuff->pduInfo.SduDataPtr[1];
        txBuff->pduInfo.SduDataPtr[2] = rxBuff->pduInfo.SduDataPtr[2];
	    txBuff->pduInfo.SduLength = 0x03u + readLength;
        Dcm_SendRsp();
    }
    
    return;
}
#endif

/******************************************************************************/
/**
 * @brief               <handle service 0x2E write data by identifier>
 * 
 * <handle service 0x2E write data by identifier> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <NONE>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <NONE>    
 */
/******************************************************************************/
void Dcm_RecvMsg2E(const Dcm_BuffType * rxBuff,Dcm_BuffType * txBuff)
{
    uint16 writeDid;
    uint8 writeTableIndex = DCM_WRITEDID_NUM;
    const Dcm_WriteDidRowType * writeTablePtr = Dcm_WriteDidRow;
    boolean didFind = FALSE;
    boolean processContinue = TRUE;
    (void)txBuff; /* to avoid compiler warning */

	/* get write data Id */
    writeDid = ((uint16)rxBuff->pduInfo.SduDataPtr[1]) << 0x08u;
    writeDid += (uint16)rxBuff->pduInfo.SduDataPtr[2];
    
    /* find write data Id in configured write data table */
    while ((writeTableIndex > 0) && (FALSE == didFind))
    {
        writeTableIndex --;
        if (writeDid == writeTablePtr->DID)
        {
            didFind = TRUE;
        }
        else
        {
            writeTablePtr ++;
        }
    }

	/* if did not find DID,send NRC */
    processContinue = Dcm_CheckReqOutOfRange(didFind);
   
    if (TRUE == processContinue)
    {
    	/* check if received message length is right, other wise send NRC */
        processContinue = Dcm_CheckMsgLength(writeTablePtr->dataLength + 0x03u,rxBuff->pduInfo.SduLength);
    }

    if (TRUE == processContinue)
    {
    	/* check if DID is supportted in current security level, other wise send NRC */
        processContinue = Dcm_CheckSecurityCondition(writeTablePtr->securitySupp);
    }
    
    if (TRUE == processContinue)
    {        	
        FL_ResultType writeRet;
        
        /* excute write API,return read length */
        writeRet = writeTablePtr->writeDataFct(&rxBuff->pduInfo.SduDataPtr[3],writeTablePtr->dataLength);

		/* if write data acceptted, wait for write pending */
        if (FL_OK != writeRet)
        {
            /* program finger print failure */
            Dcm_SendNcr(DCM_E_GENERAL_PROGRAMMING_FAILURE);
        }
    }
    
    return;
}

/******************************************************************************/
/**
 * @brief               <handle service 0x27 securtiy access>
 * 
 * <handle service 0x27 securtiy access> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <NONE>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <NONE>    
 */
/******************************************************************************/
void Dcm_RecvMsg27(const Dcm_BuffType * rxBuff,Dcm_BuffType * txBuff)
{

    Dcm_SessionType secId = rxBuff->pduInfo.SduDataPtr[1];
    uint8 secTableIndex = DCM_SECURITY_NUM;
    const Dcm_SecurityRowType * secTablePtr = Dcm_SecurityRow;
    boolean secIdFind = FALSE;
    boolean processContinue = TRUE; 

	/* find subfunction Id in configered security table */
    while ((secTableIndex > 0) && (FALSE == secIdFind))
    {
        secTableIndex --;
        if ((secId == secTablePtr->reqSeedId) || 
            (secId == secTablePtr->sendKeyId))
        {
            secIdFind = TRUE;
        }
        else
        {
            secTablePtr ++;
        }
    }
    
    /* if did not find subfunction,send NRC */ 
    processContinue = Dcm_CheckSubFuncFind(secIdFind,rxBuff);
    
    if (TRUE == processContinue)
    {
    	/* check if subfunciton is supportted in current session, other wise send NRC */
        processContinue = Dcm_CheckSubFuncSession(secTablePtr->sessionSupp);
    }  
    
    if (TRUE == processContinue)
    {
        uint16 checkLength;
        
        if (secId == secTablePtr->reqSeedId)
        {
            checkLength = 0x02u;
        }
        else
        {
            checkLength = 0x06u;
        }
        
        /* check if received message length is right, other wise send NRC */
        processContinue = Dcm_CheckMsgLength(checkLength,rxBuff->pduInfo.SduLength);
    }

    if (TRUE == processContinue)
    {
    	/* check if subfunction is supported in current security level, other wise send NRC */
        processContinue = Dcm_CheckSecurityCondition(secTablePtr->securitySupp);
    }
    
    if (TRUE == processContinue)
    {
    	/* check if security timer is expired */
        if (FALSE == Dcm_GetSecurityTimerExpired())
        {
            /* security access timer delay is not expired */
            Dcm_SendNcr(DCM_E_REQUIRED_TIME_DELAY_NOT_EXPIRED);
        }
        else
        {
            if (secId == secTablePtr->reqSeedId)
            {
                Dcm_RequestSeed(secTablePtr,rxBuff,txBuff);
            }
            else
            {
                Dcm_SendKey(secTablePtr,rxBuff,txBuff);
            }
        }
    }    

    return;
}

#if (DCM_COM_CONTROL_NUM > 0)
/******************************************************************************/
/**
 * @brief               <handle service 0x28 communication control>
 * 
 * <handle service 0x28 communication control> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <NONE>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <NONE>    
 */
/******************************************************************************/
void Dcm_RecvMsg28(const Dcm_BuffType * rxBuff,Dcm_BuffType * txBuff)
{
    Dcm_ComControlType controlValue = rxBuff->pduInfo.SduDataPtr[1];
    uint8 comTableIndex = DCM_COM_CONTROL_NUM;
    const Dcm_ComControlRowType * comTablePtr = Dcm_ComControlRow;
    boolean controlTypeFind = FALSE;
    boolean processContinue = TRUE;

	/* find communication control type in configered table */
    while ((comTableIndex > 0) && (FALSE == controlTypeFind))
    {
        comTableIndex --;
        
        if (controlValue == comTablePtr->controlType)
        {
            controlTypeFind = TRUE;
        }
        else
        {
            comTablePtr ++;
        }
    }
    
    /* if did not find subfunciton,send NRC */
    processContinue = Dcm_CheckSubFuncFind(controlTypeFind,rxBuff);
    
    if (TRUE == processContinue)
    {
    	/* check if subfunciton is supportted in current session, other wise send NRC */
        processContinue = Dcm_CheckSubFuncSession(comTablePtr->sessionSupp);
    }  
    
    if (TRUE == processContinue)
    {
    	/* check if received message length is right, other wise send NRC */
        processContinue = Dcm_CheckMsgLength(0x03u,rxBuff->pduInfo.SduLength);
    }

    if (TRUE == processContinue)
    {
    	/* check if subfunction is supportted in current security level, other wise send NRC */
        processContinue = Dcm_CheckSecurityCondition(comTablePtr->securitySupp);
    }

    if (TRUE == processContinue)
    {
        Dcm_CommunicationType communicationType = rxBuff->pduInfo.SduDataPtr[2];
        
        /* check if communication type is correct */
        if (DCM_NORMAL_COM_MESSAGES == communicationType)
        {
            /* set response message */		
    	    txBuff->pduInfo.SduDataPtr[0] = 0x68u;
    	    txBuff->pduInfo.SduDataPtr[1] = rxBuff->pduInfo.SduDataPtr[1];
    	    txBuff->pduInfo.SduLength = 0x02u;
            Dcm_SendRsp();
        }
        else
        {
            /* Request out of range */
            Dcm_SendNcr(DCM_E_REQUEST_OUT_OF_RANGE);
        }
    }
    
    return;	
}
#endif

/******************************************************************************/
/**
 * @brief               <handle service 0x34 request download>
 * 
 * <handle service 0x34 request download> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <NONE>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <NONE>    
 */
/******************************************************************************/
void Dcm_RecvMsg34(const Dcm_BuffType * rxBuff,Dcm_BuffType * txBuff)
{
    boolean processContinue = TRUE;

	/* check if received message length is right, other wise send NRC */
    processContinue = Dcm_CheckMsgLength(0x0Bu,rxBuff->pduInfo.SduLength);

    if (TRUE == processContinue)
    {
    	/* check if service is supported in current security level, other wise send NRC */
        processContinue = Dcm_CheckSecurityCondition(Dcm_DownloadRow.securitySupp);
    }

    if (TRUE == processContinue)
    {
        uint8 formatId = rxBuff->pduInfo.SduDataPtr[1];
        uint8 dataFormat = rxBuff->pduInfo.SduDataPtr[2];
        
        /* check if format Id and data format is correct */
        if ((0x00u == formatId) && 
            (0x44u == dataFormat))
        {
            uint32 programSize;
            FL_ResultType requestRet;

            /* set program index to 0, for service 0x36 */
            dcmDspProgram.blockId = 0x00u;

            /* get program address */
            dcmDspProgram.address =  Dcm_Get4Byte(&rxBuff->pduInfo.SduDataPtr[3]);

            /* get program length */
            programSize =  Dcm_Get4Byte(&rxBuff->pduInfo.SduDataPtr[7]);

            /* check if program address and length is correct */
            requestRet = FL_DownloadRequestValid(dcmDspProgram.address,programSize);
            
            if (FL_OK == requestRet)
            {
                /* set response message */		
        	    txBuff->pduInfo.SduDataPtr[0] = 0x74u;
        	    txBuff->pduInfo.SduDataPtr[1] = 0x20u;
        	    txBuff->pduInfo.SduDataPtr[2] = (uint8)(DCM_RX_BUF_SIZE >> 0x08u);
        	    txBuff->pduInfo.SduDataPtr[3] = (uint8)DCM_RX_BUF_SIZE;
        	    txBuff->pduInfo.SduLength = 0x04u;
                Dcm_SendRsp();
            }
            else if (FL_ERR_SEQUENCE == requestRet)
            {
                /* 0x34,0x36,0x37 service sequence is not correct */
                Dcm_SendNcr(DCM_E_CONDITION_NOT_CORRECT);
            }
            else if ((FL_NO_FINGERPRINT == requestRet) || 
                     (FL_NO_FLASHDRIVER == requestRet))
            {
                /* finger print is not written */
                Dcm_SendNcr(DCM_E_UPLOAD_DOWNLOAD_NOT_ACCEPTED);
            }
            else
            {
                /* Request out of range */
                Dcm_SendNcr(DCM_E_REQUEST_OUT_OF_RANGE);
            }
        }
        else
        {
            /* Request out of range */
            Dcm_SendNcr(DCM_E_REQUEST_OUT_OF_RANGE);
        }
    }
        
    return;
}

/******************************************************************************/
/**
 * @brief               <handle service 0x36 transfer data>
 * 
 * <handle service 0x36 transfer data> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <NONE>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <NONE>    
 */
/******************************************************************************/
void Dcm_RecvMsg36(const Dcm_BuffType * rxBuff,Dcm_BuffType * txBuff)
{
    boolean processContinue = TRUE;
    (void)txBuff; /* to avoid compiler warning */
    (void)rxBuff; /* to avoid compiler warning */

	/* check if received message length is right, other wise send NRC */
    processContinue = Dcm_CheckMsgLength(0x03u,rxBuff->pduInfo.SduLength);

    if (TRUE == processContinue)
    {
    	/* check if service is supported in current security level, other wise send NRC */
        processContinue = Dcm_CheckSecurityCondition(Dcm_DownloadRow.securitySupp);
    }

    if (TRUE == processContinue)
    {
        /* get program block index */
        uint8 dataBlockId = rxBuff->pduInfo.SduDataPtr[1];
        
        /* index programmed block index */
        if (0xFFu == dcmDspProgram.blockId)
        {
            dcmDspProgram.blockId = 0;
        }
        else
        {
            dcmDspProgram.blockId ++;
        } 
        
        if (dcmDspProgram.blockId != dataBlockId)
        {
            /* program block index is not correct */
            Dcm_SendNcr(DCM_E_WRONG_BLOCK_SEQUENCE_COUNTER);
        }
        else
        {
            uint32 programSize = (uint32)rxBuff->pduInfo.SduLength - 0x02uL;
            FL_ResultType programRet;
            
            /* execute program routine */
            programRet = FL_FlashProgramRegion (dcmDspProgram.address,
                                                &rxBuff->pduInfo.SduDataPtr[2],
                                                programSize);
            /* index program address */
            dcmDspProgram.address += programSize;
            
            if (FL_ERR_SEQUENCE == programRet)
            {
                /* 0x34,0x36,0x37 service sequence is not correct */
                Dcm_SendNcr(DCM_E_REQUEST_SEQUENCE_ERROR);
            }
            else if (FL_ERR_ADDR_LENGTH == programRet) 
            {
                /* program length is not the same as received in 0x34 service */
                Dcm_SendNcr(DCM_E_TRANSFER_DATA_SUSPENDED);
            }   
            else
            {
                /* wait for pending */
            } 
        }
    }
    
    return;	
}

/******************************************************************************/
/**
 * @brief               <handle service 0x37 exit transfer data>
 * 
 * <handle service 0x37 exit transfer data> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <NONE>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <NONE>    
 */
/******************************************************************************/
void Dcm_RecvMsg37(const Dcm_BuffType * rxBuff,Dcm_BuffType * txBuff)
{
    boolean processContinue = TRUE;

	/* check if received message length is right, other wise send NRC */
    processContinue = Dcm_CheckMsgLength(0x01u,rxBuff->pduInfo.SduLength);

    if (TRUE == processContinue)
    {
    	/* check if service is supported in current security level, other wise send NRC */
        processContinue = Dcm_CheckSecurityCondition(Dcm_DownloadRow.securitySupp);
    }

    if (TRUE == processContinue)
    {
        FL_ResultType programRet;
        
        /* execute transfer data exit */
        programRet = FL_ExitTransferData();
                    
        if (FL_OK == programRet)
        {
            /* set response message */		
    	    txBuff->pduInfo.SduDataPtr[0] = 0x77u;
    	    txBuff->pduInfo.SduLength = 0x01u;
            Dcm_SendRsp();
        }
        else 
        {
            /* 0x34,0x36,0x37 service sequence is not correct */
            Dcm_SendNcr(DCM_E_REQUEST_SEQUENCE_ERROR);
        }   
    }
    
    return;
}

/******************************************************************************/
/**
 * @brief               <handle service 0x31 routine control>
 * 
 * <handle service 0x31 routine control> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <NONE>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <NONE>    
 */
/******************************************************************************/
void Dcm_RecvMsg31(const Dcm_BuffType * rxBuff,Dcm_BuffType * txBuff)
{
    boolean processContinue = TRUE;
    uint16 routineIdValue;
    const Dcm_RoutineControlRowType * routineTablePtr = Dcm_RoutineControlRow;
    /* get routine control type */
    uint8 routineControlValue = rxBuff->pduInfo.SduDataPtr[1];

	/* check if subfunction is start routine */
    if (DCM_START_ROUTINE != routineControlValue)
    {
    	/* if did not find subfunction,send NRC */
        processContinue = Dcm_CheckSubFuncFind(FALSE,rxBuff);
    }
    
    if (TRUE == processContinue)
    { 
        uint8 routineTableIndex = DCM_ROUTINE_CONTROL_NUM;
        boolean routineIdFind = FALSE;
        
        /* get routine Id */
        routineIdValue = ((uint16)rxBuff->pduInfo.SduDataPtr[2]) << 0x08u;
        routineIdValue += (uint16)rxBuff->pduInfo.SduDataPtr[3];
        
        /* find routine Id in routine table */
        while ((routineTableIndex > 0) && (FALSE == routineIdFind))
        {
            routineTableIndex --;
            if ((routineIdValue == routineTablePtr->routineId) &&
                ((DCM_RX_PHY_PDU_ID == rxBuff->pduId) || 
                 ((DCM_RX_FUNC_PDU_ID == rxBuff->pduId) && 
                  (TRUE == routineTablePtr->funcAddrSupp))))
            {
                routineIdFind = TRUE;
            }
            else
            {
                routineTablePtr ++;
            }
        }

		/* if routine Id is not found,send NRC */
        processContinue = Dcm_CheckReqOutOfRange(routineIdFind);
    }

    if (TRUE == processContinue)
    {
    	/* check if subfunction is supported in current session, other wise send NRC */
        processContinue = Dcm_CheckSubFuncSession(routineTablePtr->sessionSupp);
    }
    
    if (TRUE == processContinue)
    {
    	/* check if received message length is right, other wise send NRC */
        processContinue = Dcm_CheckMsgLength(0x03u + (uint16)routineTablePtr->optionLength,
                                             rxBuff->pduInfo.SduLength);
    }

    if (TRUE == processContinue)
    {
    	/* check if subfunction is supported in current security level, other wise send NRC */
        processContinue = Dcm_CheckSecurityCondition(routineTablePtr->securitySupp);
    }

    if (TRUE == processContinue)
    {
        /* set response message */		
        txBuff->pduInfo.SduDataPtr[0] = 0x71u;
        txBuff->pduInfo.SduDataPtr[1] = rxBuff->pduInfo.SduDataPtr[1];
        txBuff->pduInfo.SduDataPtr[2] = rxBuff->pduInfo.SduDataPtr[2];
        txBuff->pduInfo.SduDataPtr[3] = rxBuff->pduInfo.SduDataPtr[3];
        
        /* execute routine */
        routineTablePtr->routineControl(rxBuff,txBuff);
    }
    
    return;
}


/******************************************************************************/
/**
 * @brief               <handle service 0x31 check program pre-condition>
 * 
 * <handle service 0x31 check program pre-condition> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <NONE>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <NONE>    
 */
/******************************************************************************/
void Dcm_CheckProgPreCondition(const Dcm_BuffType * rxBuff,Dcm_BuffType * txBuff)
{
    uint8 conditionLength;
    (void)txBuff; /* to avoid compiler warning */
    (void)rxBuff; /* to avoid compiler warning */
    
    /* execute routine for check programming preconditions */
    conditionLength = FL_CheckProgPreCondition(&txBuff->pduInfo.SduDataPtr[4]);

    if (0x01u == conditionLength)
    {
    	/* programming pre-conditions is accepted */
        dcmDspProgram.condition = TRUE;
    }
    else
    {
    	/* programming preconditions is not accepted */
        dcmDspProgram.condition = FALSE;
    }
    
    /* set response message */			
    txBuff->pduInfo.SduLength = (PduLengthType)conditionLength + 0x04u;
    Dcm_SendRsp();
            
    return;
}

/******************************************************************************/
/**
 * @brief               <handle service 0x31 check dependency>
 * 
 * <handle service 0x31 check dependency> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <NONE>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <NONE>    
 */
/******************************************************************************/
void Dcm_CheckProgDependencies(const Dcm_BuffType * rxBuff,Dcm_BuffType * txBuff)
{
    FL_ResultType consistencyStatus;
    (void)rxBuff; /* to avoid compiler warning */
    
    /* Write block headers */
    FL_WriteBlockHeaders();

    /* execute routine for check application software dependency */
    consistencyStatus = Appl_CheckConsistency();
    
    /* set response message */
    if (FL_OK == consistencyStatus)
    {
        *(uint8 *)FL_APPL_UPDATE = FL_APPL_UPDATED;
        txBuff->pduInfo.SduDataPtr[4] = 0x00u;
    }
    else
    {
        txBuff->pduInfo.SduDataPtr[4] = 0x01u;
    }
        
    txBuff->pduInfo.SduLength = 0x05u;
    
    Dcm_SendRsp();
    
    return;
}

/******************************************************************************/
/**
 * @brief               <handle service 0x31 enter test software>
 * 
 * <handle service 0x31 enter test software> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <NONE>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <NONE>    
 */
/******************************************************************************/
void Dcm_Enter_Tsw(const Dcm_BuffType * rxBuff,Dcm_BuffType * txBuff)
{
    FL_ResultType consistencyStatus;
    (void)rxBuff; /* to avoid compiler warning */
    
    /* execute routine  */
    consistencyStatus = 0;
    
    /* set response message */
    if (FL_OK == consistencyStatus)
    {
        /**(uint8 *)FL_APPL_UPDATE = FL_APPL_UPDATED;*/
        txBuff->pduInfo.SduDataPtr[4] = 0x00u;
    }
    else
    {
        txBuff->pduInfo.SduDataPtr[4] = 0x01u;
    }
        
    txBuff->pduInfo.SduLength = 0x05u;
    
    Dcm_SendRsp();
    
    Board_Tsw();
    
    Board_Reset();
    
    
    return;
}

/******************************************************************************/
/**
 * @brief               <handle service 0x31 checksum>
 * 
 * <handle service 0x31 checksum> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <NONE>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <NONE>    
 */
/******************************************************************************/
void Dcm_CheckMemory(const Dcm_BuffType * rxBuff,Dcm_BuffType * txBuff)
{
    FL_ResultType checksumRet;
    (void)txBuff; /* to avoid compiler warning */

    /* execute checksum routine */
    checksumRet = FL_CheckSumRoutine(&rxBuff->pduInfo.SduDataPtr[12]);
    
    if (FL_OK == checksumRet)
    {
        /* wait for pending */ 
    }
    else if (FL_ERR_SEQUENCE == checksumRet)
    {
        /* checksum sequence error,no fingerprint or download data */
        Dcm_SendNcr(DCM_E_REQUEST_SEQUENCE_ERROR);
    }
    else
    {
        Dcm_SendNcr(DCM_E_CONDITION_NOT_CORRECT);
    }

    return;
}

/******************************************************************************/
/**
 * @brief               <handle service 0x31 erase block>
 * 
 * <handle service 0x31 erase block> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <NONE>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <NONE>    
 */
/******************************************************************************/
void Dcm_EraseMemory(const Dcm_BuffType* rxBuff, Dcm_BuffType* txBuff)
{ 
   FL_ResultType eraseRet;
   uint8 eraseBlockId = rxBuff->pduInfo.SduDataPtr[5];
   (void)txBuff;  /* to avoid compiler warning */

    /* excute erase routine */
    eraseRet = FL_EraseRoutine(eraseBlockId);
    
    if (FL_OK == eraseRet)
    {
        /* wait for pending */
    }
    else if ((FL_NO_FINGERPRINT == eraseRet) ||
             (FL_ERR_SEQUENCE == eraseRet) || 
             (FL_NO_FLASHDRIVER == eraseRet))
    {
        /* erase sequence error,no fingerprint or download data */
        Dcm_SendNcr(DCM_E_REQUEST_SEQUENCE_ERROR);
    }
    else if (FL_INVALID_DATA == eraseRet)
    {
        Dcm_SendNcr(DCM_E_REQUEST_OUT_OF_RANGE);
    }
    else
    {
        Dcm_SendNcr(DCM_E_CONDITION_NOT_CORRECT);
    }

    return;
}

/******************************************************************************/
/**
 * @brief               <handle service 0x3E test precent>
 * 
 * <handle service 0x3E test precent> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <NONE>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <NONE>    
 */
/******************************************************************************/
void Dcm_RecvMsg3E(const Dcm_BuffType * rxBuff,Dcm_BuffType * txBuff)
{
    boolean positiveRspReq = TRUE;
    boolean processContinue = TRUE;
    
    if (DCM_RX_FUNC_PDU_ID == rxBuff->pduId)
    {
    	/* check if response needed */
        if ((rxBuff->pduInfo.SduDataPtr[1] & DCM_RSP_NOT_REQUIRED) > 0x00u)
        {
            positiveRspReq = FALSE;
        }
    }
    
    /* check if received message length is right, other wise send NRC */
    processContinue = Dcm_CheckMsgLength(0x02u,rxBuff->pduInfo.SduLength);
    
    if (TRUE == processContinue)
    {
        if (TRUE == positiveRspReq)
        {
            /* set response message */		
		    txBuff->pduInfo.SduDataPtr[0] = 0x7Eu;
		    txBuff->pduInfo.SduDataPtr[1] = 0x00u;
		    txBuff->pduInfo.SduLength = 0x02u;
            Dcm_SendRsp();
        }
        else
        {
            /* reset service process */
            Dcm_ServiceFinish();
        }
    }
    
    return;	
}

#if (DCM_DTC_SET_NUM > 0)
/******************************************************************************/
/**
 * @brief               <handle service 0x85 set DTC control>
 * 
 * <handle service 0x85 set DTC control> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <NONE>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <NONE>    
 */
/******************************************************************************/
void Dcm_RecvMsg85(const Dcm_BuffType * rxBuff,Dcm_BuffType * txBuff)
{
    Dcm_DTCSettingType DTCsetType = rxBuff->pduInfo.SduDataPtr[1];
    uint8 DTCsetTableIndex = DCM_DTC_SET_NUM;
    const Dcm_DTCSettingRowType * DTCsetTablePtr = Dcm_DTCSettingRow;
    boolean DTCsetTypeFind = FALSE;
    boolean processContinue = TRUE;

	/* find DTC setting subfunction */
    while ((DTCsetTableIndex > 0) && (FALSE == DTCsetTypeFind))
    {
        DTCsetTableIndex --;
        if (DTCsetType == DTCsetTablePtr->DTCSet)
        {
            DTCsetTypeFind = TRUE;
        }
        else
        {
            DTCsetTablePtr ++;
        }
    }
    
    /* if did not find subfunciton,send NRC */
    processContinue = Dcm_CheckSubFuncFind(DTCsetTypeFind,rxBuff);
    
    if (TRUE == processContinue)
    {
    	/* check if subfunciton is supportted in current session, other wise send NRC */
        processContinue = Dcm_CheckSubFuncSession(DTCsetTablePtr->sessionSupp);
    }  
    
    if (TRUE == processContinue)
    {
    	/* check if received message length is right, other wise send NRC */
        processContinue = Dcm_CheckMsgLength(0x02u,rxBuff->pduInfo.SduLength);
    }

    if (TRUE == processContinue)
    {
    	/* check if DID is supportted in current security level, other wise send NRC */
        processContinue = Dcm_CheckSecurityCondition(DTCsetTablePtr->securitySupp);
    }

    if (TRUE == processContinue)
    {
        /* set response message */		
	    txBuff->pduInfo.SduDataPtr[0] = 0xC5u;
	    txBuff->pduInfo.SduDataPtr[1] = rxBuff->pduInfo.SduDataPtr[1];
	    txBuff->pduInfo.SduLength = 0x02u;
        Dcm_SendRsp();
    }
    
    return;	
}
#endif

/******************************************************************************/
/**
 * @brief               <handle service 0x2E write data pending finish>
 * 
 * <handle service 0x2E write data pending finish> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <errorCode (IN),rxBuff (IN),>
 * @param[out]          <NONE>
 * @param[in/out]       <txBuff (IN/OUT)>
 * @return              <NONE>    
 */
/******************************************************************************/
void Dcm_Pending2E(const FL_ResultType errorCode,
                   const Dcm_BuffType * rxBuff,
                   Dcm_BuffType * txBuff)
{
	/* check if write data successful */
    if (FL_OK == errorCode)
    {
	    txBuff->pduInfo.SduDataPtr[0] = 0x6Eu;
	    txBuff->pduInfo.SduDataPtr[1] = rxBuff->pduInfo.SduDataPtr[1];
        txBuff->pduInfo.SduDataPtr[2] = rxBuff->pduInfo.SduDataPtr[2];
	    txBuff->pduInfo.SduLength = 0x03u;
        Dcm_SendRsp();
    }
    else
    {
        /* program finger print failure */
        Dcm_SendNcr(DCM_E_GENERAL_PROGRAMMING_FAILURE);
    }
    
    return;
}

/******************************************************************************/
/**
 * @brief               <handle service 0x36 transfer data pending finish>
 * 
 * <handle service 0x36 transfer data pending finish> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <errorCode (IN),rxBuff (IN),>
 * @param[out]          <NONE>
 * @param[in/out]       <txBuff (IN/OUT)>
 * @return              <NONE>    
 */
/******************************************************************************/
void Dcm_Pending36(const FL_ResultType errorCode,
                   const Dcm_BuffType * rxBuff,
                   Dcm_BuffType * txBuff)
{
	/* check if program data successful */
    if (FL_OK == errorCode)
    {
	    txBuff->pduInfo.SduDataPtr[0] = 0x76u;
	    txBuff->pduInfo.SduDataPtr[1] = rxBuff->pduInfo.SduDataPtr[1];
	    txBuff->pduInfo.SduLength = 0x02u;
        Dcm_SendRsp();
    }
    else
    {
        /* program data failure */
        Dcm_SendNcr(DCM_E_GENERAL_PROGRAMMING_FAILURE);
    }
    
    return;
}

/******************************************************************************/
/**
 * @brief               <handle service 0x31 routine control pending finish>
 * 
 * <handle service 0x31 routine control pending finish> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <errorCode (IN),rxBuff (IN),>
 * @param[out]          <NONE>
 * @param[in/out]       <txBuff (IN/OUT)>
 * @return              <NONE>    
 */
/******************************************************************************/
void Dcm_Pending31(const FL_ResultType errorCode,
                   const Dcm_BuffType * rxBuff,
                   Dcm_BuffType * txBuff)
{
  	/* check if execute routine successful */
    if (FL_OK == errorCode)
    {
        txBuff->pduInfo.SduDataPtr[4] = 0x00u;
    }
    else
    {
        /* execute routine failure */
        txBuff->pduInfo.SduDataPtr[4] = 0x01u;
    }
    
    txBuff->pduInfo.SduDataPtr[0] = 0x71u;
    txBuff->pduInfo.SduDataPtr[1] = rxBuff->pduInfo.SduDataPtr[1];
    txBuff->pduInfo.SduDataPtr[2] = rxBuff->pduInfo.SduDataPtr[2];
    txBuff->pduInfo.SduDataPtr[3] = rxBuff->pduInfo.SduDataPtr[3];
    txBuff->pduInfo.SduLength = 0x05u;
    Dcm_SendRsp();  
    
    return;
}

/******************************************************************************/
/**
 * @brief               <get uint32 from data buffer>
 * 
 * <get uint32 from data buffer> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <data (IN)>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <uint32>    
 */
/******************************************************************************/
STATIC uint32 Dcm_Get4Byte(const uint8* data)
{
    uint32 retData;
    
    retData = ((uint32)data[0]) << 24;
    retData += ((uint32)data[1]) << 16;
    retData += ((uint32)data[2]) << 8;
    retData += (uint32)data[3];
    
    return retData;
}

/******************************************************************************/
/**
 * @brief               <set uint32 to data buffer>
 * 
 * <set uint32 to data buffer> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <data (IN)>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <uint32>    
 */
/******************************************************************************/
STATIC void Dcm_Set4Byte(uint8* destData,const uint32 sourceData)
{
    destData[0] = (uint8)(sourceData >> 24u);
    destData[1] = (uint8)(sourceData >> 16u);
    destData[2] = (uint8)(sourceData >> 8u);
    destData[3] = (uint8)sourceData;
    
    return;
}

/******************************************************************************/
/**
 * @brief               <check if subfunction is supported in current session>
 * 
 * <check if subfunction is supported in current session> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <sessionTable (IN)>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <boolean>    
 */
/******************************************************************************/
STATIC boolean Dcm_CheckSubFuncSession(const Dcm_SessionType * sessionTable)
{
    boolean ret;

    ret = Dcm_CheckSessionSupp(sessionTable);
    
    if (FALSE == ret)
    {
        /* subfunction is not supportted in active session*/
        Dcm_SendNcr(DCM_E_SUBFUNC_NOT_SUPPORTED_INACTIVE_SESSION);
    }

    return ret;
}

/******************************************************************************/
/**
 * @brief               <check if receive message length is correct>
 * 
 * <check if receive message length is correct> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <minlength (IN),receivedLength (IN)>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <boolean>    
 */
/******************************************************************************/
STATIC boolean Dcm_CheckMsgLength(const uint16 minlength,
                                  const uint16 receivedLength)
{
    boolean ret = TRUE;
    
    if (receivedLength < minlength)
    {
        ret = FALSE;
        
        /* service length is not correct */
        Dcm_SendNcr(DCM_E_INCORRECT_MESSAGE_LENGTH_OR_INVALID_FORMAT);
    }

    return ret;
}


/******************************************************************************/
/**
 * @brief               <check if service is supportted in current security level>
 * 
 * <check if service is supportted in current security level> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <secLevTable (IN)>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <boolean>    
 */
/******************************************************************************/
STATIC boolean Dcm_CheckSecurityCondition(const Dcm_SecurityType * secLevTable)
{
    boolean ret; 

    ret = Dcm_CheckSecuritySupp(secLevTable);
    
    if (FALSE == ret)
    {
        /* security condition is not correct */
        Dcm_SendNcr(DCM_E_SECURITY_ACCESS_DENIED);
    }

    return ret;
}

/******************************************************************************/
/**
 * @brief               <check if subfunction is finded>
 * 
 * <check if subfunction is finded> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <find (IN),rxBuff (IN)>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <boolean>    
 */
/******************************************************************************/
STATIC boolean Dcm_CheckSubFuncFind(const boolean find,
                                    const Dcm_BuffType * rxBuff)
{
    boolean ret = find; 
    
    if (FALSE == ret)
    {
        if (DCM_RX_PHY_PDU_ID == rxBuff->pduId)
        {
            /* subfunction is not supportted */
            Dcm_SendNcr(DCM_E_SUBFUNC_NOT_SUPPORTED);
        }
        else
        {
            /* reset service process */
            Dcm_ServiceFinish();
        }
    }

    return ret;
}

/******************************************************************************/
/**
 * @brief               <check if condition is correct in service>
 * 
 * <check if condition is correct in service> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <condition (IN)>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <boolean>    
 */
/******************************************************************************/
STATIC boolean Dcm_CheckConditionCorrect(const boolean condition)
{
    boolean ret = condition; 
    
    if (FALSE == ret)
    {
        /* condition is not correct */
        Dcm_SendNcr(DCM_E_CONDITION_NOT_CORRECT);
    }

    return ret;
}

/******************************************************************************/
/**
 * @brief               <check if request is out of range>
 * 
 * <check if request is out of range> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <condition (IN)>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <boolean>    
 */
/******************************************************************************/
STATIC boolean Dcm_CheckReqOutOfRange(const boolean condition)
{
    boolean ret = condition; 
    
    if (FALSE == ret)
    {
        /* Request out of range */
        Dcm_SendNcr(DCM_E_REQUEST_OUT_OF_RANGE);
    }

    return ret;
}

/******************************************************************************/
/**
 * @brief               <execute generate seed>
 * 
 * <execute generate seed> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <secTablePtr (IN),rxBuff (IN)>
 * @param[out]          <NONE>
 * @param[in/out]       <txBuff (IN/OUT)>
 * @return              <NONE>    
 */
/******************************************************************************/
STATIC void Dcm_RequestSeed(const Dcm_SecurityRowType * secTablePtr,
                            const Dcm_BuffType * rxBuff,
                            Dcm_BuffType * txBuff)
{
	/* check if seed has requested */
    if ((TRUE == dcmDspSec.seedReq) && 
        (dcmDspSec.seedIdReq == secTablePtr->reqSeedId))
    {
    	/* if seed has requested, seed is 0x00 */
        dcmDspSec.seed.seedX = 0x00uL;
        dcmDspSec.seed.seedY = 0x00uL;
    }
    else
    {
        dcmDspSec.seedReq = TRUE;
        
        /* record received seed Id */
        dcmDspSec.seedIdReq = secTablePtr->reqSeedId;
        
        /* execute generate seed */
        (void)secTablePtr->generateSeed(&dcmDspSec.seed);
    }
    
    /* set response message */
    txBuff->pduInfo.SduDataPtr[0] = 0x67u;
    txBuff->pduInfo.SduDataPtr[1] = rxBuff->pduInfo.SduDataPtr[1];
    Dcm_Set4Byte(&txBuff->pduInfo.SduDataPtr[2],dcmDspSec.seed.seedX);
    Dcm_Set4Byte(&txBuff->pduInfo.SduDataPtr[6],dcmDspSec.seed.seedY);
    txBuff->pduInfo.SduLength = 0x06u; /* set the length of positive data,the original data is 0x0au. */
    
    Dcm_SendRsp();

    return;
}

/******************************************************************************/
/**
 * @brief               <execute compare key>
 * 
 * <execute compare key> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <secTablePtr (IN),rxBuff (IN)>
 * @param[out]          <NONE>
 * @param[in/out]       <txBuff (IN/OUT)>
 * @return              <NONE>    
 */
/******************************************************************************/
STATIC void Dcm_SendKey(const Dcm_SecurityRowType * secTablePtr,
                        const Dcm_BuffType * rxBuff,
                        Dcm_BuffType * txBuff)
{
	/* check if seed has requested */
    if ((TRUE == dcmDspSec.seedReq) && 
        (dcmDspSec.seedIdReq == secTablePtr->reqSeedId))
    {
        SecM_KeyType receivedKey;
        SecM_StatusType compareStatus;

        dcmDspSec.seedReq = FALSE;
        
        /* get received key */
        receivedKey = (SecM_KeyType)Dcm_Get4Byte(&rxBuff->pduInfo.SduDataPtr[2]);
        
        /* compare key */
        compareStatus = secTablePtr->compareKey(receivedKey,dcmDspSec.seed);

		/* check if compare key successful */
        if (SECM_OK == compareStatus)
        {
        	/* set to requested security level */
            Dcm_SetSecurityLevel(secTablePtr->secAccessLevel);
            
            /* clear security access attempt num */
            dcmDspSec.attempt = 0x00u;
            
            /* set response message */
            txBuff->pduInfo.SduDataPtr[0] = 0x67u;
            #if ENABLE_DFLZ_AlGORITHM 
            txBuff->pduInfo.SduDataPtr[1] = 0x0au;
            #else
            txBuff->pduInfo.SduDataPtr[1] = rxBuff->pduInfo.SduDataPtr[1];
            #endif
            txBuff->pduInfo.SduLength = 0x02u;
            Dcm_SendRsp();
        }
        else
        {
        	/* set to requested security level */
            Dcm_SetSecurityLevel(DCM_SECURITY_LOCKED);
            
        	/* compare key fialed, increat security access attempt num */
            dcmDspSec.attempt ++;
			/* security access attempt num is overflow,*/
            if(dcmDspSec.attempt < DCM_SECURITY_ATTEMPT_NUM)
            {
                /* the sent key is invalid */
                Dcm_SendNcr(DCM_E_INVALID_KEY);   
            }
            else
            {
                /* num of security access is exceeded */
                dcmDspSec.attempt = 0;
                
                /* start security timer */
                Dcm_StartSecurityTimer(DCM_SECURITY_TIME);
                
                /* send NRC */
                Dcm_SendNcr(DCM_E_EXCEEDED_NUMBER_OF_ATTEMPTS);
            }
        }
    }
    else
    {
        /* seed is not sent */
        Dcm_SendNcr(DCM_E_REQUEST_SEQUENCE_ERROR);
    }

    return;
}
